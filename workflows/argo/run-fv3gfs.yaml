apiVersion: argoproj.io/v1alpha1
kind: WorkflowTemplate
metadata:
  name: run-fv3gfs
spec:
  entrypoint: run-fv3gfs
  templates:
  - name: run-fv3gfs
    inputs:
      artifacts:
        - name: fv3config
        - name: runfile
      parameters:
        - name: output-url
        - {name: chunks, value: "{}"}
        - {name: cpu, value: "6"}
        - {name: memory, value: 8Gi}
        - {name: segment-count, value: "1"}
    steps:
      - - template: create-run
          name: create-run
          arguments:
            parameters:
            - {name: runURL, value: "{{inputs.parameters.output-url}}"}
            - {name: cpu, value: "{{inputs.parameters.cpu}}"}
            - {name: memory, value: "{{inputs.parameters.memory}}"}
            - {name: chunks, value: "{{inputs.parameters.chunks}}"}
            artifacts:
              - name: fv3config
                from: "{{inputs.artifacts.fv3config}}"
              - name: runfile
                from: "{{inputs.artifacts.runfile}}"
      # loop over segments implemented through recursion so that a failed segment will
      # terminate the workflow. Argo loops by default run in parallel and do not fail fast.
      - - name: run-first-segment  
          template: run-all-segments
          arguments:
            parameters:
            - {name: output-url, value: "{{inputs.parameters.output-url}}"}
            - {name: cpu, value: "{{inputs.parameters.cpu}}"}
            - {name: memory, value: "{{inputs.parameters.memory}}"}
            - {name: segment-count, value: "{{inputs.parameters.segment-count}}"}
            - {name: segment, value: 0}
  - name: run-all-segments
    inputs:
      parameters:
        - name: output-url
        - name: cpu
        - name: memory
        - name: segment-count
        - name: segment
    steps:
      - - template: append-segment
          name: append-segment 
          arguments:
            parameters:
              - {name: runURL, value: "{{inputs.parameters.output-url}}"}
              - {name: cpu, value: "{{inputs.parameters.cpu}}"}
              - {name: memory, value: "{{inputs.parameters.memory}}"}
      - - name: increment-segment
          template: increment-count
          arguments:
            parameters:
              - {name: count, value: "{{inputs.parameters.segment}}"}
      - - name: run-next-segment
          template: run-all-segments
          when: "{{steps.increment-segment.outputs.result}} < {{inputs.parameters.segment-count}}"
          arguments:
            parameters:
            - {name: output-url, value: "{{inputs.parameters.output-url}}"}
            - {name: cpu, value: "{{inputs.parameters.cpu}}"}
            - {name: memory, value: "{{inputs.parameters.memory}}"}
            - {name: segment-count, value: "{{inputs.parameters.segment-count}}"}
            - {name: segment, value: "{{steps.increment-segment.outputs.result}}"}
  - name: create-run
    inputs:
      artifacts:
        - name: fv3config
          path: /mnt/data/fv3config.yaml
        - name: runfile
          path: /mnt/data/runfile.py
      parameters:
        - name: cpu
        - name: memory
        - name: runURL
        - name: chunks
    tolerations:
    - key: "dedicated"
      operator: "Equal"
      value: "climate-sim-pool"
      effect: "NoSchedule"
    podSpecPatch: |
      containers:
        - name: main
          resources:
            limits:
              cpu: "{{inputs.parameters.cpu}}"
              memory: "{{inputs.parameters.memory}}"
            requests:
              cpu: "{{inputs.parameters.cpu}}"
              memory: "{{inputs.parameters.memory}}"
    container:
      image: us.gcr.io/vcm-ml/prognostic_run
      command: ["/bin/bash", "-c", "-x", "-e"]
      args:
      - |
        find /mnt/data
        echo "Using runfile:"
        cat /mnt/data/runfile.py
        echo "Using fv3config:"
        cat /mnt/data/fv3config.yaml
        echo "{{inputs.parameters.chunks}}" > chunks.yaml
        runfv3.sh create {{inputs.parameters.runURL}} /mnt/data/fv3config.yaml chunks.yaml /mnt/data/runfile.py
      env:
        - name: GOOGLE_APPLICATION_CREDENTIALS
          value: /secret/gcp-credentials/key.json
        - name: CLOUDSDK_AUTH_CREDENTIAL_FILE_OVERRIDE
          value: /secret/gcp-credentials/key.json
      terminationMessagePath: /dev/termination-log
      terminationMessagePolicy: File
      volumeMounts:
        - name: gcp-key-secret
          mountPath: /secret/gcp-credentials
          readOnly: true
  - name: append-segment
    inputs:
      parameters:
        - name: cpu
        - name: memory
        - name: runURL
    tolerations:
    - key: "dedicated"
      operator: "Equal"
      value: "climate-sim-pool"
      effect: "NoSchedule"
    podSpecPatch: |
      containers:
        - name: main
          resources:
            limits:
              cpu: "{{inputs.parameters.cpu}}"
              memory: "{{inputs.parameters.memory}}"
            requests:
              cpu: "{{inputs.parameters.cpu}}"
              memory: "{{inputs.parameters.memory}}"
    container:
      image: us.gcr.io/vcm-ml/prognostic_run
      command: [runfv3.sh]
      args: ["append", "{{inputs.parameters.runURL}}"]
      env:
        - name: GOOGLE_APPLICATION_CREDENTIALS
          value: /secret/gcp-credentials/key.json
        - name: CLOUDSDK_AUTH_CREDENTIAL_FILE_OVERRIDE
          value: /secret/gcp-credentials/key.json
      terminationMessagePath: /dev/termination-log
      terminationMessagePolicy: File
      volumeMounts:
        - name: gcp-key-secret
          mountPath: /secret/gcp-credentials
          readOnly: true
  - name: increment-count
    inputs:
      parameters:
        - name: count
    script:
      image: python:alpine3.6
      command: [python]
      source: |
        print({{inputs.parameters.count}} + 1)
